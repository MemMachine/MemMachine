---
title: "Episodic Memory Manager"
description: "Public Interfaces that call Episodic Memory Manager"
icon: "list-check"
---
## EpisodicMemoryManager Class Reference

```python
class EpisodicMemoryManager()
```

Manages the creation and lifecycle of `EpisodicMemory` instances, serving as a factory and central registry.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.create_episodic_memory_manager"></a>

### create_episodic_memory_manager (Internal)

```python
@classmethod
def create_episodic_memory_manager(cls, config_path: str)
```

The singleton factory method used **internally** to create and initialize the manager instance. It handles configuration loading, logging setup, and default prompt initialization.

**Arguments**:

- `config_path`: The path to the main configuration file (e.g., `memmachine.yaml`).

**Returns**:

The single, shared instance of `EpisodicMemoryManager`.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.create_group"></a>

### create_group

```python
async def create_group(self, group_id: str,
                       agent_ids: list[str] | None,
                       user_ids: list[str] | None)
```

Registers a new conversation **group** within the system. A group defines the permanent participants (users and agents). You **must** create a group before you can create a session within it.

**Arguments**:

- `group_id`: The unique ID for the group (e.g., `"team_alpha"`).
- `agent_ids`: A list of agent IDs belonging to this group.
- `user_ids`: A list of user IDs belonging to this group.

------
## Recommended Session Lifecycle Management (Async Context Managers)

We **strongly recommend** using the `async with` context managers below. They ensure memory resources are safely opened and automatically closed, decrementing the reference count when the block is exited.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.async_open_episodic_memory_instance"></a>



### async_open_episodic_memory_instance

```python
@asynccontextmanager
async def async_open_episodic_memory_instance(
    self,
    group_id: str,
    session_id: str,
)
```

Opens an **existing session** and safely retrieves its `EpisodicMemory` instance. If the instance is already active, it safely increments the reference count. The instance is closed automatically upon exiting the `async with` block.

**Arguments**:

- `group_id`: The ID of the group the session belongs to.
- `session_id`: The ID of the existing session to open.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.async_create_episodic_memory_instance"></a>

### async_create_episodic_memory_instance

```python
@asynccontextmanager
async def async_create_episodic_memory_instance(
    self,
    group_id: str,
    session_id: str,
    configuration: dict | None = None
)
```

Creates a **brand new session** and its corresponding `EpisodicMemory` instance using the `async with` pattern. The instance is closed automatically upon exiting the block. This method will fail if the `session_id` already exists within the `group_id`.

**Arguments**:

- `group_id`: The ID of the group the session belongs to (must exist).
- `session_id`: The unique identifier for this new session.
- `configuration`: *Optional.* A dictionary for session-specific settings that override the manager's default configuration.

------

## Direct Session Access Methods (Advanced)

These methods provide direct, manual control over the memory instance. **You are responsible for manually calling `close_episodic_memory_instance`** when finished to prevent memory leaks.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.create_episodic_memory_instance"></a>

### create_episodic_memory_instance

```python
async def create_episodic_memory_instance(
        self,
        group_id: str,
        session_id: str,
        configuration: dict | None = None
) -> EpisodicMemory
```

Manually creates a **brand new session** and the corresponding `EpisodicMemory` instance.

**Arguments**:

- `group_id`: The ID of the group the session belongs to (must exist).
- `session_id`: The unique identifier for this new session.
- `configuration`: *Optional.* A dictionary for session-specific settings.

**Returns**:

A new, ready-to-use `EpisodicMemory` instance.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.open_episodic_memory_instance"></a>

### open_episodic_memory_instance

```python
async def open_episodic_memory_instance(
    self,
    group_id: str,
    session_id: str
) -> EpisodicMemory
```

Manually opens an **existing session** and retrieves its `EpisodicMemory` instance. It increments the reference count before returning the instance.

**Arguments**:

- `group_id`: The ID of the group.
- `session_id`: The ID of the existing session.

**Returns**:

The live `EpisodicMemory` instance for the specified context.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.close_episodic_memory_instance"></a>



### close_episodic_memory_instance

```python
async def close_episodic_memory_instance(
    self,
    group_id: str,
    session_id: str,
) -> bool
```

Manually closes an active memory instance, decrementing the reference count. If this was the last active reference, the memory instance is removed from the manager's registry. **You must call this** if you used `create_episodic_memory_instance` or `open_episodic_memory_instance`.

------

## Session Retrieval and Metadata

These methods provide access to configuration and metadata managed by the underlying `SessionManager`.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.session_manager"></a>

### session_manager (Property)

```python
@property
def session_manager(self) -> SessionManager
```

Provides direct access to the internal `SessionManager` object for advanced data persistence control.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.configuration"></a>

### configuration (Property)

```python
@property
def configuration(self) -> dict
```
Returns the base configuration dictionary loaded by the manager during initialization.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_group_configuration"></a>

### get_group_configuration

```python
def get\_group\_configuration(self, group_id: str) -> GroupConfiguration | None
```

Retrieves the specific configuration object (including participant IDs) for a registered group.

**Arguments**:

- `group_id`: The ID of the group whose configuration is needed.

**Returns**:

The `GroupConfiguration` object, or `None` if the group ID is not found.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_all_sessions"></a>

### get_all_sessions

```python
def get\_all\_sessions(self) -> list[SessionInfo]
```

Retrieves metadata for **all** recorded sessions from the underlying storage.

**Returns**:

A list of `SessionInfo` objects.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_group_sessions"></a>

### get_group_sessions

```python
def get\_group\_sessions(self, group_id: str) -> list[SessionInfo]
```

Retrieves all session metadata associated with a specific group ID.

**Arguments**:

- `group_id`: The ID of the group.

**Returns**:

A list of `SessionInfo` objects for the given group.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_user_sessions"></a>

### get_user_sessions

```python
def get\_user\_sessions(self, user_id: str) -> list[SessionInfo]
```

Retrieves all session metadata associated with a specific user ID.

**Arguments**:

- `user_id`: The ID of the user.

**Returns**:

A list of `SessionInfo` objects for the given user.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_agent_sessions"></a>

### get_agent_sessions

```python
def get\_agent\_sessions(self, agent_id: str) -> list[SessionInfo]
```

Retrieves all session metadata associated with a specific agent ID.

**Arguments**:

- `agent_id`: The ID of the agent.

**Returns**:

A list of `SessionInfo` objects for the given agent.

------

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.shut_down"></a>

### shut_down

```python
async def shut\_down(self)
```

Safely shuts down the entire manager. It iterates through all currently active `EpisodicMemory` instances and forces them to close, ensuring all system resources are released.

<a id="memmachine.episodic_memory_manager.EpisodicMemoryManager.get_episodic_memory_instance"></a>

### get_episodic_memory_instance (Legacy)

```python
async def get_episodic_memory_instance(
    self,
    group_id: str,
    agent_id: list[str] | None = None,
    user_id: list[str] | None = None,
    session_id: str = "",
    configuration: dict | None = None,
) -> EpisodicMemory | None
```

A comprehensive, legacy method that retrieves a memory instance. If the session does not exist, it attempts to create it automatically. This method is retained for backward compatibility but is **not recommended** for new development due to its complexity.

<Note>For explicit, controlled session lifecycle, use the `async_create_*` or `async_open_*` context managers.</Note>